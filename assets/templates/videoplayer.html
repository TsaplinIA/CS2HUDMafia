{% extends "layout.html" %}
{% block header %}
<div class="d-flex justify-content-between align-items-center">
    <div class="row g-2 align-items-center">
        <div class="col">
            <h2 class="page-title">
                Videoplayer
            </h2>
        </div>
    </div>
</div>
{% endblock %}
{% block content %}

<div class="container-fluid">
    <div class="row">
        <div class="card">
            <div class="card-header"></div>
            <div class="card-body">

                {# ---- ВИДЕО + HUD В ОДНОМ КОНТЕЙНЕРЕ ---- #}
                <div class="video-hud-wrapper">
                    <video id="video" src="/files/video/trimed.mp4" controls></video>

                    {# HUD-страница, рендерящаяся в 1920x1080 и скейлящаяся вместе с видео #}
                    <iframe
                        id="hud-frame"
                        src="/huds/JT"      {# подставь свой URL #}
                        frameborder="0"
                        allowtransparency="true"
                        scrolling="no">
                    </iframe>
                </div>
                {# ---- /ВИДЕО + HUD ---- #}

                <div id="log"></div>
            </div>
        </div>
    </div>
</div>

<script>
    const EVENTS_URL = '/files/video/dump_sync.json';  // JSON с событиями
    const POST_URL = '/gsi/hud'; // Куда шлём POST

    let events = [];          // [{ frame, time, payload, id }, ...] — будет отсортирован
    let videoFps = 25;
    let nextEventIndex = 0;   // указатель на следующее событие, которое надо отправить

    function log(msg) {
      const el = document.getElementById('log');
      const time = new Date().toLocaleTimeString();
      el.innerHTML = `[${time}] ${msg}<br>` + el.innerHTML;
    }

    async function sendPost(payload, id) {
      try {
        const res = await fetch(POST_URL, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload),
        });
        if (!res.ok) {
          log(`POST ${id} вернул статус ${res.status}`);
        } else {
          log(`POST отправлен для ${id}`);
        }
      } catch (e) {
        log(`Ошибка POST для ${id}: ${e}`);
      }
    }

    // Считаем все события, чей frame <= currentFrame, в правильном порядке
    function processFrame(currentFrame) {
      while (nextEventIndex < events.length &&
             events[nextEventIndex].frame <= currentFrame) {
        const e = events[nextEventIndex];
        sendPost(e.payload, e.id);
        nextEventIndex++;
      }
    }

    // Находим индекс первого события с frame >= targetFrame
    function resetPointerToFrame(targetFrame) {
      let lo = 0;
      let hi = events.length;
      while (lo < hi) {
        const mid = (lo + hi) >> 1;
        if (events[mid].frame < targetFrame) {
          lo = mid + 1;
        } else {
          hi = mid;
        }
      }
      nextEventIndex = lo;
      log(`Seek: перенос указателя на событие #${nextEventIndex} (frame >= ${targetFrame})`);
    }

    function setupWithVideoFrameCallback(video) {
      log('Используем requestVideoFrameCallback (точно по кадрам)');

      const callback = (now, metadata) => {
        // ВАЖНО: используем mediaTime, а не presentedFrames
        const currentTime = metadata.mediaTime; // в секундах
        const currentFrame = Math.round(currentTime * videoFps);
        processFrame(currentFrame);
        video.requestVideoFrameCallback(callback);
      };

      video.requestVideoFrameCallback(callback);

      // При завершении seek — пересчитываем указатель
      video.addEventListener('seeked', () => {
        const t = video.currentTime;
        const frame = Math.round(t * videoFps);
        resetPointerToFrame(frame);
      });
    }

    function setupWithTimeupdate(video) {
      log('Fallback: используем timeupdate (примерно по времени)');

      video.addEventListener('timeupdate', () => {
        const t = video.currentTime;
        const currentFrame = Math.round(t * videoFps);
        processFrame(currentFrame);
      });

      video.addEventListener('seeked', () => {
        const t = video.currentTime;
        const frame = Math.round(t * videoFps);
        resetPointerToFrame(frame);
      });
    }

    async function init() {
      const video = document.getElementById('video');

      const res = await fetch(EVENTS_URL);
      const data = await res.json();
      videoFps = data.fps || 25;

      events = data.events.map((e, idx) => ({
        frame: e.frame,
        time: e.time,
        payload: e.payload,
        id: e.id || `event_${idx}_frame_${e.frame}`
      }));

      // Сортируем по frame на всякий случай
      events.sort((a, b) => a.frame - b.frame);
      nextEventIndex = 0;

      log(`Загружено событий: ${events.length}, fps = ${videoFps}`);

      if ('requestVideoFrameCallback' in HTMLVideoElement.prototype) {
        setupWithVideoFrameCallback(video);
      } else {
        setupWithTimeupdate(video);
      }
    }

    init();
</script>

<style>
    /* Контейнер 16:9 под видео и HUD */
    .video-hud-wrapper {
        position: relative;
        max-width: 100%;
        aspect-ratio: 16 / 9; /* 1920x1080 */
        margin-bottom: 16px;
    }

    .video-hud-wrapper video,
    .video-hud-wrapper iframe {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        display: block;
    }

    /* Если HUD только отображает данные, а не интерактивный — так он не будет мешать кликам по плееру */
    .video-hud-wrapper iframe {
        pointer-events: none;
    }

    /* Если нужен интерактивный HUD — убери правило выше и подумай,
       как ты хочешь, чтобы обрабатывались клики (HUD vs контролы видео) */

    #log {
      font-size: 14px;
      max-height: 200px;
      overflow-y: auto;
      border: 1px solid #ddd;
      padding: 8px;
      border-radius: 4px;
      background: #fafafa;
    }
</style>
{% endblock %}
